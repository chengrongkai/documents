## 项目背景
撮合银行账户解决平台型商户资金二清分账问题，撮合的意思是，银行不需要直接外放自己的内部户体系，通过银联对接商户，防止风险侵入

## 名词解释
1. 资金管理系统：为各类交易平台的用户提供账户管理、支付结算、资金存管等服提供资金管理相关 API 服务。
2. 银联：处于系统最顶级角色，可以查看或管理其他各业务角色（如银行、互联网平台等）的数据和权限。
3. 银行：由银联负责进件审核，拥有管理和监管互联网平台以及下级角色的数据和权限。
4. 互联网平台：交易平台/平台商户，对接资金管理系统 API 的客户，由银行负责进件审核，拥有管理平台下二级商户和个人用户数据的权限。
5. 二级商户：子商户/企业用户，互联网平台下的商户（通常是卖家或供应商），由银行负责进件审核，可以进行收款、分账等交易操作。
6. 个人用户：互联网平台下的个人用户（通常是买家），由系统负责进件审核，可以进行充值、支付等交易操作。
7. 结算账户：实体账户/银行账户/绑定账户，互联网平台、二级商户、个人拥护拥有的记录真实资金流的银行账户，首个结算账户通常由进件资料生成绑定，并支持后续绑定多个结算账户。
8. 母户：母账户/监管账户，属于结算账户的一种特殊账户类型。互联网平台进件完成后，由监管银行为其开立的资金监管实体账户。该账户映射了自身以及其平台下各二级商户或个人用户的余额账户，互联网平台没有对该账户直接的资金转移等权限。
9. 余额账户：余额户/虚拟账户/虚户/附属账户/子账户，互联网平台进件完成后，由互联网平台根据自身或其二级商户/个人用户的需求，通过 API 创建的余额账户，该账户挂在平台的监管账户下，受所属银行监管。
10. 可提现余额：已清算余额，平台用户完成支付充值且充值金额已清算至平台监管户的余额状态。可用于转账（消费）、担保下单、支付分账与提现交易。
11. 在途余额：待清算余额/充值在途，平台用户已支付充值，但充值金额尚未清算至平台监管账户的在途余额状态。该部分余额仅可于转账（消费）、担保下单交易，不可用于支付分账及提现交易。充值金额完成清算后转换为已清算状态。
12. 不可用余额：待清算收款余额/消费在途，指用户 A 使用待清算余额转账（消费）至用户 B 账户后，该部分余额在完成资金清算前的余额状态。该部分余额无法再用于各类交易。直至清算完成后，该余额状态转为已清算状态。
13. 提现在途：提现中余额，指用户 A 使用已清算余额发起提现后，提现操作尚未被银行受理成功时的中间状态。
14. 冻结余额：余额冻结后，冻结部分的余额不可进行交易直至解冻。
15. 支付分账：指一个余额账户同时向多个其他余额账户转账的交易。
16. 担保交易：指买家使用余额付款后，资金不会立刻结算到卖家余额账户，而是先记录于互联网平台的担保账户内，由买家确认收货后，再结算到卖家余额账户的交易。
17. 系统单号：指由本系统产生资源的唯一标识。商户可用该单号用于相应的查询等处理。
18. 商户单号：指由客户系统生成、提交的唯一单号。本系统会使用该单号来判断请求的唯一性。
19. 交易授权码：余额账户出金时(提现、消费等)需要验证的交易授权码。

## 项目概览

### 架构图

### 技术点

### 项目结构图

### 账户关系图

### 交易变化图

### 进件


## 余额账户详情

### 电子账簿类型

电子账簿大致可以分为两种：基本户和功能户。类型为0的为基本户，其他的都是功能户。只有平台会有功能户，二级商户和个人用户只会存在基本户。


#### 电子账簿

- 平台和所有用户进件成功后都会生成电子账簿。
- 用于平台所有交易业务，如充值、提现、消费转账等。
- 支持平台调用接口冻结电子账簿，冻结后不允许发起交易，但不影响虚户入账。

#### 电子账簿余额状态

- **在途余额**: 第三方充值后用户电子账簿直接增加的余额。
- **不可用余额**: 在途余额进行账户间交易后到达另一个用户的电子账簿的余额。
  - 特点：不可以再次进行除退款以外的账户间交易，也不可以提现。
  - 再次进行账户间交易需等T+1日入账为可提现余额。
- **可提现余额**: 除了可以用于消费类账户间交易外，还可以发起提现。
  - 来源：
    1. T日充值产生的在途余额，T+1日收到三方结算款项后，由系统执行批量入账操作，将在途余额/不可用余额变为可提现余额。
    2. 用户通过线下网银转账的方式，填写收款方银行账号为电子账簿号，进行汇款（转账入金或虚户入金）。
    3. 通过大小额通道发起的提现，由于提现最终失败产生的退汇入金（超网通道不会产生提现退汇）。

### 功能户

功能户指平台功能户，该类账户仅属于平台，且每种类型的功能户平台仅有一个。功能户用于发生交易时，辅助基本户的一些额外记账记录。

#### 0: 基本户

- 仅用于对外接口的交易，用作基本的一些交易，比如充值、消费、提现等。
- 每个二级商户或个人用户最多可以创建10个基本户。
- 根据场景不同，每个基本户可能会存在可提现余额、在途余额、不可用余额。
- 需要与银行绑定。
- 可用于虚户入金。

#### 1: 挂账户

- 用于记录母户入金的资金。
- 挂账户的金额仅用于批量入账（系统自动处理），不可用于其他一般交易。
- 仅会存在可提现余额，不会出现在途余额、不可用余额。

#### 2: 手续费户

- 用于记录提现时平台侧收取的手续费。
- 可以通过提现接口提现，不可用于其他交易。
- 需要与银行绑定。
- 仅会存在可提现余额，不会出现在途余额、不可用余额。

#### 3: 充值户

- 用于记录充值交易产生的金额，即在途金额。
- 不可用于交易。
- 仅会存在在途余额，不会出现可提现余额、不可用余额。

#### 4: 提现在途户

- 用于记录提现过程中，从电子账簿扣除，但银行侧状态未定的金额。
- 不可用于交易。
- 仅会存在可提现余额，不会出现在途余额、不可用余额。

#### 5: 担保户

- 用于记录担保消费、担保支付产生的担保金额。
- 不可用于交易。
- 根据场景不同，可能会存在可提现余额、在途余额，不会出现不可用余额。

#### 6: 垫资户

- 预留用于垫资相关交易的户。
- 仅会存在可提现余额，不会出现在途余额、不可用余额。
- 需要与银行绑定。
- 可提现。
- 可用于虚户入金。

#### 7: 营销户

- 目前仅用于营销支付的营销金额预充值。
- 发起营销支付时，营销部分的金额，需要从该账簿扣除。
- 需要与银行绑定。
- 可提现。
- 可用于虚户入金。

#### 8: 银行存款户

- 是银行监管户的一个“映射”户，用于记录监管账户实际入金和出金的明细。
- 虚户入金、母户入金、提现（成功）、提现退汇，都涉及到监管户的资金变动，所以都应该有相应的银行存款户明细。
- 仅会存在可提现余额，不会出现在途余额、不可用余额。
- 该户的可提现余额等于其他所有户（包括平台、二级商户、个人用户的，包括基本户和其他功能户）的可提现余额之和。

#### 9: 内部户映射户

- 一个特殊的户，本身不参与记账，仅用作与银行内部户（监管户）的绑定。
- 任何往这个电子账簿账簿号转账的操作，都会被当作母户入金处理。
- 需要与银行绑定。
- 不应该有任何余额，也不应该有任何的明细关联。

#### 10: 营销挂账户

- 用于记录营销支付还未入账时的待入账金额记录。
- 不可用于交易。
- 仅会存在可提现余额，不会出现在途余额、不可用余额。
- 有点类似于“挂账户”，但金额的来源是营销户，不是母户入金。

#### 11: 营销在途户

- 用于记录营销支付还未入账时的在途金额记录。
- 这个余额应该等于营销挂账户的余额。
- 不可用于交易。
- 仅会存在在途余额，不会出现可提现余额、不可用余额。
- 有点类似于“充值户”。

#### 12: 冻结户

- 用于记录平台下所有电子账簿的已冻结余额（目前仅支持可提现余额2021-05-17）。

#### 13: 入金挂账户

- 用于记录虚户入金、大额入金银行到账时，还未处理至目标电子账簿的金额。
- 处理银行的入金通知/流水时，先记账到入金挂账户。
- 等验证通过再记账到目标电子账簿。
- 验证不通过，发起原路退回。

### 汇总可提现

- 这不是一个电子账簿类型，仅用于管理后台展示的一个统计值。
- 表达的意思应该是平台当前总共可用于提现的金额，具体计算公式参考下方：
  $$
  \text{汇总可提现余额} = \text{银行存款账簿余额} - \text{提现在途账簿余额} - \text{挂账账簿余额} - \text{担保账簿可提现余额} - \text{冻结户可提现余额} - \text{营销挂账户可提现余额} - \text{入金挂账户}
  $$

- 目前管理后台展示的其他信息（比如账簿号）是用的“银行存管户”的信息。

## 余额

### 余额类型

- 可提现金额
- 在途金额
- 不可用金额

目前的余额类型就只有这三种，后续虽然有增加“冻结余额”，但冻结余额的其实是把余额转移至冻结户，流转于交易中电子账簿之间的余额的类型还是这三种。

发生冻结余额的电子账簿本身，会额外记录被冻结的一个总金额而已。

### 可提现金额

### 在途金额

### 不可用金额

### 金额使用优先级

例如对于消费来说，会优先使用可提现余额，没有足够的可提现余额时，再去使用在途余额。不可用余额不能用于交易。

1. 可提现余额 → 可提现余额
2. 在途余额 → 不可用余额

对于退款来说，优先级相反，会优先退原交易中包含的不可用余额，退完不可用余额再退可提现余额。

1. 不可用余额 → 在途余额
2. 可提现余额 → 可提现余额


## 系统模块划分

以下是系统的各个模块及其描述：

| 模块名 | 描述 |
|---|---|
| **商户进件** | 负责银联机构、银行机构、互联网平台、二级商户、个人用户进件及交易费率配置，以及一些辅助功能如短信验证码、图片上传等。 |
| **交易** | 负责处理各类余额相关交易，如充值、消费、分账、提现等。 |
| **账户** | 负责开立和管理余额账户、结算账户。在交易产生时记录余额相关明细及状态。 |
| **对账** | 负责交易记账、日切交易数据对账，差错处理，提供账单报表下载功能。 |
| **银行网关** | 负责打通银行核心系统，将银行核心系统的接口封装成资金流相关的请求，例如将银行转账接口封装成提现操作。 |
| **管理后台** | 管理各机构角色的登录账号、角色和权限，调用其他模块如商户进件、交易、钱包、账单模块完成各类数据操作。 |


## 云直通架构设计
### 核心要素
1. 可用性：单个节点应用与60个节点微服务集群的可用性指标SLA对比
99.999-年平均停机(故障)时间5.26分钟
99.94-年平均停机(故障)时间525.6分钟
系统没有容错,将出现一个非关键服务的异常拖垮整个集群
2. 伸缩性：SAAS租户隔离
    - 系统隔离：按平台进行分组部署，分为共享组、独享组
    - 数据隔离：按平台进行分库， 分为共享库、独享库
    - 业务隔离：按业务拆分现有交易，占比较大的交易独立应用处理
3. 安全性：
    1. 银联安全规范
        - 针对《银联外包系统安全检查表》
        - 不符合项进行整改,如SSO接入等
    2. 过程数据一致性稽查
        - 完善内部对账机制,针对交易与
        账户、账户与账户之间、热点账
        户余额,进行数据一致稽核检查,
        确保及时发现长短款、差错账等
        异常,及时发现资损异常;
    3. 系统业务异常告警
        - 针对各模块处理逻辑关键节点进
        行梳理,并添加关键字监控告警,
        主动发现系统例外(异常)情况,
        进行人工处理
4. 性能：
    1. 技术方案重构
        - 业务流程重构
        - 开源组件升级
        - 动静分离
        - 消息队列
    2. 并发优化
        - 多线程并发
        - 定时任务分片
        - 热点账户并发
    3. 数据读写
        - 分库分表
        - 读写分离
        - 索引优化
        - 多级缓存
        - 数据归档
        - ES检索
    4. 应用结构
        - 应用拆分
        - 部署结构调整
### 逻辑架构

### 技术架构

### 部署架构

### 技术实现

#### 对账流程

1. 基本思路
    - 数据收集：通过BINLOG+MQ获取内部数据（交易明细、账户流水），通过银行外部对账单定时获取外部数据（银行流水）
    - 数据预比对：将获取到的对账源数据按照时间段范围+约定的格式写入redis的set集合中，利用set的交集、差集快速对账，只处理对账成功的数据
    - 数据比对：针对得到的交集和差集分别进行处理
        - 交集：进入到数据复核的阶段
        - 差集：循环处理较多部分的集合，根据关键KEY信息查询较少集合的库数据，如果能匹配上则更新为对账成功，否则记为差错，进入后续的差错处理
    - 数据复核： 通过关键KEY信息，分别查询ES获取详细数据再次比对，匹配上则更新为对账成功，否则记为差错
    - 差错处理：取消对账、长短款处理
2. 关键点
    - 通过BINLOG日志近实时收集数据
    - 通过Redis缓存快速完成预对账
    - 预对账完成后还需要通过DB数据再次复核
    - 完善的差错处理
    - 对账单数据需要定期处理
    - 数据收集/对账需要按照业务量隔离处理
3. 对账类型
    - 内部对账：交易账单和内部账户明细比对
    - 外部对账：交易账单和银行流水

# 对账优化方案

## 1. 背景

随着业务的不断发展，日交易量将达到千万级别，对账数据量也将达到千万级别，对现有对账模式将造成压力。现有的对账模式已经不能支撑千万级别的数据对账，随着数据量的增大，现有对账模式将面临以下问题：

1. **问题一**：对账数据存取都使用DB，没有使用Redis缓存或ES等高性能搜索引擎。目前是可以支撑对账的，但是当数据量大时，会造成效率低，对账完成将使用更长的时间，可能会导致对账完成不了或出错的风险，甚至会压垮DB。

2. **问题二**：对账平台每隔10分钟去查询获取交易系统DB和账户系统DB，当交易量达到千万级别时，会对交易系统和账户系统造成很大的压力。

3. **问题三**：虽然每日都会生成一张日对账表 `trade_checks_202xxxxx`，但是该表非常大，字段特别多，每一条没有差错的记录都包含交易数据、余额明细数据，如果交易类型为“提现成功”的，还会包含银行对账单的数据。由于单行数据的大小过于庞大，对于检索查询带来速度慢的问题，在未来大数据量对账中会受到严重影响，而且单表存放的数据有限，如果支持千万级别的数据量，将会很慢。

4. **问题四**：对账数据是基于DB检索出来一行行的比对，没有批量比对，效率慢。

从上述问题分析，现有的对账模式已经不能满足未来千万级别的数据对账，需要重新考虑方案进行优化。

## 2. 设计目标

业务对账平台设计目标主要从以下几点出发：

- 方便交易业务对账场景接入，实现交易业务场景覆盖。
- 能够处理海量交易数据比对，全方位核对，降低不一致数据的出现概率。
- 针对业务快速迭代开发，实现灵活调整对账业务逻辑以及对账相关的配置。
- 为不一致比对结果提供对账链路的数据快照，方便定位问题。
- 海量数据比对要考虑性能及稳定性。
- 实现自动对账，自动修复，减少人力成本（后续会做）。
- 提供丰富的可视化业务比对图表，供业务方监控当前数据的比对情况（后续）。

## 3. 对账概述

对账步骤可划分为以下三个阶段：

- 数据准备
- 逻辑比对
- 比对结果处理

### 3.1 数据准备

#### 3.1.1 对账数据获取的新老方式对比

| 数据类型 | 数据来源 | 老的获取方式 | 新的获取方式 |
| --- | --- | --- | --- |
| 交易数据 | unionpay_trade | 直接从DB库获取 | 通过canal订阅DB表的binlog，把增量数据传输到kafka获取 |
| 余额明细数据 | unionpay_wallet | 直接从DB库获取 | 通过canal订阅DB表的binlog，把增量数据传输到kafka获取 |

#### 3.1.2 数据准备流程图

### 4. 老的对账细节点

#### 4.1 预对账

1. 定时任务每隔十分钟去DB读取交易数据和明细数据存放到每日对账表 `trade_checks_2021xxxx` 中，并且对账状态 `check_status` 为“未对账”；对账完成时间 `check_finished_at`、对账失败时间 `check_failed_at`、对账失败原因 `failure_msgs` 为空。

2. 检查交易是否缺失：

   - 查询 `trade_checks_2021xxxx` 表对账状态 `check_status` 为“未对账”的记录，遍历执行每一条未对账的记录，判断交易创建时间字段 `tread_created_at` 如果为空则有差错，更新对账状态 `check_status` 为“对账有差错”，更新对账失败原因 `failure_msgs` 为“交易缺失”；更新对账失败时间 `check_failed_at` 为当前时间。

   - 注：字段 `tread_created_at` 存放的是交易表的交易 `create_at`，如果为空，则说明没有拉取到交易数据，如果拉取到交易数据，则该字段会存放交易的创建时间 `crated_at`。

3. 检查余额明细是否缺失：

   - 检查 `trade_checks_2021xxxx` 的字段 `balance_txns` 关联的明细数组是否为空，为空则有差错，更新对账状态 `check_status` 为“对账有差错”，更新对账失败原因 `failure_msgs` 为“余额明细缺失”；更新对账失败时间 `check_failed_at`。

   - 注：字段 `balance_txns` 是一个数组，用于存放该交易所对应的余额明细。

4. 如果交易创建时间字段 `tread_created_at` 和余额明细 `balance_txns` 都不为空，则交易和明细都有了，接着检查明细。

5. 检查明细：

   5.1 根据该交易的交易类型 `tradeType`，组装期望的余额明细，期望的余额明细含：期望的明细类型 `txnType`，期望金额 `expectedAmount`，期望金额类型 `amountType`。

   - 注：提现交易有手续费，需判断手续费 `trade_fee` 不为 0 时，也组装手续费余额明细。

   5.2 获取 `balance_txns` 余额明细数组，根据期望的明细类型 `txnType` 去 `balance_txns` 数组查找，如果没有找到则有差错，更新对账状态 `check_status` 为 "对账有差错”，更新对账失败原因 `failure_msgs` 为“余额明细缺失”；更新对账失败时间 `check_failed_at` 为当前时间。

   5.3 找到期望的明细类型 `txnType` 记录后，获取记录的 `amountType` 所对应的明细金额，拿明细金额和期望金额比对，如果不一致，则金额有差错，更新对账状态 `check_status` 为“对账有差错”，更新对账失败原因 `failure_msgs` 为“金额有差错”；更新对账失败时间 `check_failed_at` 为当前时间。

#### 4.2 最终对账

1. 凌晨00:30分定时任务去查询昨天的 `trade_checks_2021xxxx` 表，查询对账状态 `check_status` 为“未对账”或“对账有差错”的记录，找到记录后，根据 `tradeId` 和 `tradeType` 去重新拉取交易和明细，并清空对账失败原因 `failure_msgs`、对账失败时间 `check_failed_at`，更新对账状态 `check_status` 为“未对账”，然后开始重新查询“未对账”记录进行对账，对账过程和预对账逻辑一样，对账有差错的，存放到差错表 `trade_errors` 中，更新对账完成时间。

2. 对账结束后，遍历 `trade_checks_2021xxxx` 表，把所有数据全部存放到对账总表 `trade_bills` 中，`trade_bills` 用于提供对账单下载的数据。

### 5. 新的对账方案

引入了 canal + kafka + redis。

#### 6. 新的对账数据准备

1. 在数据库 `unionpay_wallet` 的余额明细表 `balance_txns` 新建一个和交易同步时间的字段 `tradeAndTxnsAt`，确保交易表的一个时间和余额明细表的该字段时间值一样，以便后面对账时，根据该字段能确保交易数据和余额明细数据能落到相同的redis的交易和明细set集合里。

| 表 | 表名 | 库名 | 说明 |
| --- | --- | --- | --- |
| adjusts | 调账表 | trade |  |
| balance_freezes | 电子账簿余额冻结解冻记录表 | trade | 电子账簿余额冻结，余额解冻共用这张表，根据 `freeze_type` '1:冻结, 2:解冻’来区分 |
| credits | 批量入账 | trade |  |
| deposits | 充值订单表 | trade |  |
| discounts | 营销订单表 | trade |  |
| guarantee_confirms | 担保交易确认记录表 | trade |  |
| guarantee_deposits | 合并支付担保下单子订单表 | trade |  |
| combined_deposit_confirms | 合并充值担保确认订单表 | trade |  |
| guarantee_payments | 担保交易订单表 | trade |  |
| large_payments | 大额消费订单 | trade |  |
| payments | 消费订单（普通订单） | trade |  |
| refunds | 消费退款（普通订单） | trade |  |
| rel_acct_deposits | 虚户入金 | trade |  |
| root_acct_deposits | 母户入金 | trade |  |
| transfers | 转账表 | trade |  |
| withdrawable_deposits | 可提现充值订单表 | trade |  |
| withdrawals | 提现记录 | trade | 取现创建,取现成功,取现失败共用这张表,根据 `withdrawal_status` '提现状态(1-处理中、2-成功、3-失败)来区分取现的交易类型 |
| withdrawal_returns | 提现退汇 | trade |  |

2. canal订阅上面的交易表和余额明细表，把增量数据发送到kafka的topic里；topic的命名规则为：`reconciliation_表名`，每张表对应一个topic。

3. 每个表的topic在对账模块中都有Listener去监听消费：

   1. 监听到交易的消息后，解析该消息并转化成该交易的对象，组装期望的对账明细存放到redis里。

   2. 监听到明细的消息后，把明细转化成对账的格式存放到redis里。

4. 内部对账的交易和明细存放到redis的规则：

   - 交易数据存放到redis的代码如下：

     ```java
     String keyTime = StringAndDateUtils.getRedisSetTime(created_at); // cradte_at/finish_at/credit ed_at
     redisTemplate.opsForSet().add("tradeSet{keyTime}", adjusStr);
     ```

   - 明细数据存放到redis的代码如下：

     ```java
     String keyTime = StringAndDateUtils.getRedisSetTime(tradeAndTxnsAt);
     redisTemplate.opsForSet().add("txnsSet{keyTime}", adjusStr);
     ```

   从上面存放交易和明细数据到redis的代码可知，交易和明细的set的key的命名规则为：`tradeSet{keyTime}` 和 `txnsSet{keyTime}`

   - `keyTime` 的计算：

     配置一个生成redis的set集合的时间频率 `generationTime`，为30分钟，从00:00点作为起点算起，00:30为一个时间节点，下下一个时间节点分别为01:00，01:30，02:00，02:30，......，23:30，23:59。00:30这个时间节点会存放：00:00到00:30分钟的数据，01:00会存放：00:30到01:00的数据，其他时间节点以此类推；注意23:30分到第二天00:00这段时间的时间存放在23:59这个节点中的。

     如果该时间频率 `generationTime` 发生改变，如为15分钟，则也是从00:00点算起，00:15为一个时间节点，下下个时间节点分别为：00:30，00:45，......，23:45，23:59。

     交易set集合的命名规则为：`tradeSet:{keyTime}`，其中 `tradeSet` 是固定的，`keyTime` 就是日期加上面的时间节点，

     如：

     交易数据的 `tradeAndTxnsAt` 为2021-07-10 00:16:00.917，则会根据该 `tradeAndTxnsAt` 和 `generationTime` 算出该笔交易的 `keyTime` 为202107100030，所以这笔交易就存放到这个 `tradeSet202107100030` set集合里了；

     该交易的明细的 `tradeAndTxnsAt` 也为2021-07-10 00:16:00.917，则会根据该 `tradeAndTxnsAt` 和 `generationTime` 算出该明细的 `keyTime` 为也为202107100030，所以这笔交易的明细就存放到这个 `txnsSet202107100030` set集合里了，这样交易和该交易所关联的明细会落在相同的 `keyTime` 里了；

     总结：监听到数据后，会根据 `tradeAndTxnsAt` 和 `generationTime` 算出这条数据应该放在哪个set集合里，set的key不需要运维提前配置，因为存放时，redis的 `add()` 方法会帮我们数据存放到key中，只需算出 `keyTime` 即可知道这笔交易和关联的明细应该放到那个set集合中；

     00:30，......，23:59这些时间节点所对应的 `tradeSet{keyTime}` 和 `txnsSet{keyTime}` 集合并不一定都在redis中都有生成，如：在00:00到00:30并没有交易数据，没有执行过 `redisTemplate.opsForSet().add("tradeSet202107100030"`，那么就不存在 `tradeSet202107100030` 这个set集合，不需要运维配置每个set集合；

#### 7. 内部对账

##### 7.1 预对账

1. 开启一个任务 `PrepareTradeQuartzJob`，定时任务跑的时间怎么设置呢？

   每天的凌晨00:00开始，每隔 `generationTime+n` 分钟定时任务开始跑，如果 `generationTime` 为30分钟，`n` 为2分钟，那么会在00:32，01:02，01:32，02:02，......，定时任务会启动对账，

   如定时任务启动时间是00:32，那么00:32-2=00:30，那么 `keyTime` 就等于日期+00:30，即202107100030，对账时，就知道要从这两个 `tradeSet202107100030`，`txnsSet202107100030` set集合进行对账了；

2. 预对账处理流程：

   1. 从上面算出 `keyTime` 为202107100030后，就知道本次对账的set集合分别为 `tradeSet202107100030`，`txnsSet202107100030` set；

   2. 以交易 `tradeSet202107100030` 为准和明细 `txnsSet202107100030` 取出差集 `tradeStore202107100030`，代码实现如下所示：

     ```java
     jedis.sdiffstore("tradeStore{keyTime}",
     "tradeSet{keyTime}", "txnsSet{keyTime}");
     ```

   - 取出差集 `tradeStore202107100030`，这个差集就是和交易不一致的明细了，依次遍历该差集，获取差集记录的 `tradeId`，`tradeType`，`txnsType`，在交易的 `tradeSet202107100030` set集合里进行匹配查找，如果查找不到记录，则对账有差错：“交易缺失”，如果找到记录，则交易和明细都存在，接着对比金额是否一致，金额类型是否一致；

   - 如果对账成功，则更新对账总表 `trade_bills20210710` 的该交易的对账状态 `check_status` 为“对账成功”，对败完成时间 `check_finish_at`；

   - 如果对账失败，则更新对账总表 `trade_bills20210710` 的该交易的对账状态 `check_status` 为“对账失败”，对账失败原因 `failure_msgs`、对账失败时间 `check_failed_at`；

   3. 以明细 `txnsSet202107100030` 为准和交易 `tradeSet202107100030` 取出差集 `txnsStore202107100030`，如下所示：

     ```java
     jedis.sdiffstore("txnsStore202107100030",
     "tradeSet202107100030", "txnsSet202107100030");
     ```

   - 取出差集 `txnsStore202107100030`，这个差集就是和明细不一致的交易了，依次遍历该差集，获取差集记录的 `tradeId`，`tradeType`，`txnsType`，在明细的 `txnsSet202107100030` set集合里进行匹配查找，如果查找不到记录，则对账有差错：“明细缺失”；如果找到记录，则交易和明细都存在，接着对比金额是否一致，金额类型是否一致；

   - 如果对账成功，则更新对账总表 `trade_bills20210710` 对账状态 `check_status` 为“对账成功”，对败完成时间 `check_finish_at

## 长短款问题处理

### 一、提现重复发起（短款）

### 时间
- 2021-11-30

### 背景

1. 当天企业线2.0新版本在上线验证，调用了YZT合并支付充值接口，子订单记账完成后，交易模块消费会有基于合并支付充值ID的锁，超时时间是5分钟。

2. 由于充值子订单记账完成的时间都差不多，交易模块在处理记账完成的消息，大概率会出现锁排队的情况（都是同一个合并支付充值ID）。

3. Redisson使用的是 `subscribe`（发布订阅）方式通知其他线程可以尝试获取锁，但银联的UpRedis或者UpRedisProxy好像并不支持。

4. 所以在排队获取锁的线程，一直卡了5分钟，而且kafka的 `max.poll.interval.ms` 默认也是5分钟，导致kafka以为消费者“挂”掉了，从而进行rebalance。

5. 刚好卡住的这台机器，拉取到的批量消息里，有一个提现发起记账成功的消息，并在处理（自己并不知道被kafka剔除了）。

6. 因为rebalance，所以这个提现发起记账成功的消息又在另外一台机器上收到了，并尝试处理。

7. 提现发起记账成功的消息消费逻辑是，先去调用银行网关，再更新数据库。

8. 所以这两台机器都调用了银行网关（银行网关再调用银行，银行也没有幂等），虽然有一台更新数据库会失败。

### 核心问题

- 交易模块记账成功的消息消费未加分布式锁。
- 银行接口没有幂等。

### 解决方案

- 交易模块记账成功的消息消费加分布式锁（不仅仅依赖乐观锁）。
- Redisson使用自旋锁。
- 银行网关再加一层幂等逻辑（长期）。

### 二、虚户入金重复处理（短款）

### 时间
- 2021-12-29

### 背景

1. 银行虚户入金通知与Job查询补偿同时获取到同一条入金数据。

2. 处理虚户入金数据的逻辑里，虽然已经有分布式锁控制，但使用了查询ES判断此条入金数据是否存在。ES写入到查询到是存在延迟的，即上一个线程处理完的数据，下一个线程在ES里并没有查到。

3. 并且虚户入金表已分库分表，原来表里的唯一索引已失去作用。

4. 这样导致虚户入金在不同的表里，共插入了2行数据。

### 核心问题

- 分库分表后，原表的唯一索引已失去作用。
- 需要立刻判断数据是否存在性时，不能只到ES查询。

### 解决方案

- 插入数据时，向唯一索引表也插入数据，保证唯一性。
- ES查询不到数据时，再到唯一索引表中查找。

## 分库分表

## 热点账户

- 热点账户出现的原因主要是账户在短时间内出现大量的更新操作，导致锁的等待。
- 一般情况下用户账户不会成为热点账户，可以用乐观锁的方式来处理并发问题，例如在消费需要扣余额的时候，刚好发生退款到账需要加余额。
- 但有些场景下用户账户也可能成为热点账户，例如用户群发红包。前期暂不考虑这种情况，因为通常情况下一般都能支撑。假设余额的更新锁等待需要10ms，那么1秒内也能处理100次的账户更新。

### 主要思路

- 使用明细流水来驱动余额。
- 账户包括个人、二级商户的基本户（可提现、在途、不可用）和平台功能户（挂账户、手续费、充值户、担保户、提现户、垫资户、营销户）。

### 账户表设计

- 建议针对个人、二级商户、平台账户分别建表，以保持清晰并分担锁的等待。
- 明细表可以统一在一张表中，但建议分别建表以避免潜在的性能问题。

### PS

1. **担保下单、完成、消费退款逻辑**：需要注意非余额支付的情况下，入金大于出金才能退款（统计当天非余额支付总余额 > 非余额支付退款的总余额）。

2. **前期设计**：都是单表保存，当账户明细表、账户表快到500万行时，进行水平切分。切分后，涉及统计、分析类的功能会考虑使用ES来实现，第一期使用MySQL来实现。

#### 要求

\7
 用户账户实时记账。
- 平台、二级商户近实时记账。
- 所有的余额明细流水都有对应的结余余额，流水表、账户表的余额不能出现负数。

#### 用户账户更新逻辑

1. `SELECT 余额, version FROM balance_accts WHERE balance_acct_id = <账户ID>`
2. `UPDATE balance_accts SET 余额 = 余额 - 100, version = version + 1 WHERE balance_acct_id = A AND version = <当前版本>`（当是担保完成的时候该步骤操作是热点账户，需要异步）
3. `INSERT INTO balance_txns (买家的明细流水和结余余额)`
4. `INSERT INTO balance_txns (卖家的明细流水)`（结余余额暂时为0，结余余额未更新标识 `flag = 1`，最终需要异步更新结余余额和 `flag = 2`)
5. `UPDATE balance_accts SET 余额 = 余额 + 100, version = version + 1 WHERE balance_acct_id = B`（热点账户）

#### 充值订单流转逻辑

- 当100元全是使用可提现的余额时，不会执行6、7、8的SQL，`deposit_tracks` 表是跟踪充值订单金额的流转情况，T+1余额结转时会使用。
- `SELECT 余额, version FROM deposit_tracks WHERE A账户的充值订单`（可能存在批量或多次获取。根据未入账标志和由远至近的时间来排序取出，直到累积金额 >= 100为止）
- `UPDATE deposit_tracks SET amount = amount - 10`（可能存在批量或多次更新）
- `INSERT INTO deposit_tracks`（有100元用户A充值的订单流转到了卖家B）

#### 异步更新机制

- 上述所有操作是一个大事务，主要目的是让第5步的SQL来异步更新。
- 在执行1、2、3、4、6、7、8成功时，向MQ生产一条消息（卖家账户ID、卖家明细流水号、金额、收支类型）。当操作是担保完成的处理时，执行1、3、4、6、7、8成功时，向MQ生产两条消息（支出账户ID、支出明细流水号、金额、收支类型和收入账户ID、收入明细流水号、金额、收支类型）。
- 各功能户都有独立的功能户Topic，比如：担保户Topic、提现户Topic、营销户Topic等。

#### 消息顺序和异常处理

- 需要保证消息严格顺序，否则账户流水的结余余额就不准确，可能会出现重复消息。
- 如果不能保证消息严格顺序，流水中的结余余额可以使用定时任务来更新，MQ的消费仅处理账户余额统计。
- 定时汇总任务（也可以作为替代MQ的方案）：间隔30秒查询账户明细流水表中 `flag = 1` 的账户ID，如果存在需要逐步更新账户表和明细流水表中的结余余额，说明消息延迟超过1分钟或者30秒（使用MQ的情况下）。
- 如果出现消息丢失或者顺序的明细流水中的 `flag` 值交错出现，那证明消息可能丢失或者出现乱序现象，那可能出现账户或明细流水中结余余额为负的情况，需要同时停止MQ的消费程序并报警。（MQ方案不应该出现，定时汇总任务不会出现）

#### 注意事项

- **实时减扣**：可以使用Redis来实时计算余额，但Redis和数据库可能不一致，只会影响到扣款，但存在某段时间范围的总金额延迟统计（汇总所需时间产生的订单总金额或MQ生产到消费所需时间内产生的订单总金额），业务上关系不大。
- **Kafka消息顺序**：一定要保证同一个账户ID落在同一个partition，可以根据账户ID来hash分组来保存顺序和性能。需要注意Kafka的配置参数。
- **不考虑结余余额**：如果不考虑商户、平台侧每笔流水的结余余额，那就更简单。

### 其他问题

1. **担保下单后，平台一直不做担保完成**：系统不做处理，平台完全自己控制。后期可以支持传参数，系统根据时间自动触发，之后异步同步给他们。

### 日切余额

#### 定义

- 日切是指日切时间点，前日的期末余额（前日的日终余额）= 余额。文档中提到的日切余额是指昨日的期末余额，也是今日的期初余额。

#### 日切余额表

- 账户类型：
  - 0: 基本户（可提现、在途、不可用）
  - 1: 挂账户（可提现）
  - 2: 手续费户（可提现、在途）
  - 3: 充值户（在途）
  - 4: 提现户（可提现）
  - 5: 担保户（可提现、在途）
  - 6: 垫资户（可提现）
  - 7: 营销户（可提现）

- 平台日切核心字段：
  - 日期（yyyy-mm-dd）
  - 创建时间
  - 更新时间
  - 银行ID
  - 平台ID
  - 账户ID
  - 账户类型
  - 日终可提现余额
  - 日终在途余额
  - 日终不可用余额
  - 日终总余额

- 二级商户日切核心字段：
  - 日期（yyyy-mm-dd）
  - 创建时间
  - 更新时间
  - 银行ID
  - 平台ID
  - 商户ID
  - 账户ID
  - 账户类型
  - 日终可提现余额
  - 日终在途余额
  - 日终不可用余额
  - 日终总余额

- 用户日切核心字段：
  - 日期（yyyy-mm-dd）
  - 创建时间
  - 更新时间
  - 银行ID
  - 平台ID
  - 用户ID
  - 账户ID
  - 账户类型
  - 日终可提现余额
  - 日终在途余额
  - 日终不可用余额
  - 日终总余额

#### 日切方案

##### 平台日切余额

- **方案一**：直接统计再保存（注意数据量）
  - 直接根据平台账户ID和账户类型来分组统计，根据数据量的大小一次性或者分批统计并获取前日各余额的日终余额计算后（如果是MySQL，可以一个组合SQL计算出昨日各余额）保存至平台日切表。

- **方案二**：先查再保存，后统计再更新
  - 获取昨日各银行有交易的平台并开通功能户的账户和获取前日各余额的日终余额计算后落日切表（开通几个功能户就相应保存几行平台相关信息）。
  - 根据账户ID和账户类型分别在明细流水表统计昨日该账户类型下各总余额并更新日切表。

##### 二级商户

- 参考平台日切方案。类似方案二的时候要注意获取有效的二级商户。

##### 用户

- 参考平台日切方案。

- 或者隔日统计各银行各平台下所有用户昨日最后一条明细表，明细表有各结余余额字段。

- **取巧点**：频繁交易的用户可以根据账户表上次更新时间对比当前时间，不在同一天就可以实时记录上日各总余额并进日切表。

##### 注意事项

- 获取昨天有交易的平台、二级商户、用户账户也可以通过Redis集合的方式来同步保存（比如可以在账户模块接收到余额相关请求后把涉及到的账户ID同步到Redis），之后根据集合里的账户ID信息来作为要统计的昨日基础数据，Redis出现问题时使用上述方案来兜底。


## 批量提现申请优化

## 压测优化

## 字节数据库存储评估

## 京东3000W笔交易性能评估