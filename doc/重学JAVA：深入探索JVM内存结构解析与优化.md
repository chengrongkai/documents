
### 什么是JVM
    我们知道JAVA语言的一大特点就是跨平台运行即一次编写到处运行，那么JAVA是怎么做到这一点的呢，试想一下，如果让你开发一门语言，你要如何让你的程序能够在不同的环境下运行，类比生活中的例子，比如你现在要出国，但你只会将中文，而你所到达的地方的人们只能用英语交流，那你要怎么和别人沟通呢，很容易想到的办法就是找个中间人当翻译，那回到我们的问题上来，是不是也可以提供一个类似翻译官的东西来处理我们与环境之间的交互。JVM就是担任这样的一个角色，Java 虚拟机（JVM）是 Java 程序的运行环境，他提供了以下功能保证了我们的程序能够在跨平台下正常运行

    1. **字节码解释与执行**：JVM 接收 Java 编译器生成的字节码文件，并负责将这些字节码解释成机器相关的指令，然后执行这些指令。

    2. **内存管理**：JVM 负责管理 Java 程序的内存，包括堆内存、栈内存、方法区（永久代/元空间）等。它负责内存的分配、回收和整理，以保证程序运行时内存的稳定性和高效性。

    3. **垃圾回收**：JVM 中的垃圾回收器负责自动回收不再使用的对象和内存空间，以减少内存泄漏和提高内存利用率。垃圾回收是 Java 程序自动内存管理的核心机制之一。

    4. **即时编译（JIT 编译）**：JVM 中的即时编译器（Just-In-Time Compiler）将热点代码（被频繁执行的代码）编译成本地机器代码，以提高程序的执行效率。

    5. **异常处理**：JVM 负责监控程序的运行状态，并在出现异常时进行处理，包括抛出异常、捕获异常、执行异常处理代码等。

    6. **线程管理**：JVM 负责创建和管理 Java 程序中的线程，包括线程的调度、同步、死锁检测等。

    7. **类加载**：JVM 负责加载、连接和初始化 Java 程序中的类和接口，包括查找和加载类文件、解析类与接口的二进制数据、执行类初始化等。

    8. **安全管理**：JVM 提供安全管理机制，可以控制 Java 程序对系统资源的访问权限，保障系统安全。

    总的来说，JVM 的主要职责是提供一个独立于硬件和操作系统的运行环境，使得 Java 程序能够在不同的平台上实现跨平台的运行，并且提供了一系列的运行时支持和管理功能，以确保 Java 程序的正确运行和高效性能。

### 字节码解释与执行

JVM 接收 Java 编译器生成的字节码文件，并负责将这些字节码解释成机器相关的指令，然后执行这些指令，HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的.
换句话说，就是为了提升效率，我提前把要用表达的意思翻译好，而不用等待翻译软件实时翻译。


### JVM内存模型
JVM栈由堆、方法区，栈、本地方法栈、程序计数器等部分组成，结构图如下所示：
![](https://telegraph-image-aed.pages.dev/file/b9525aa2a34c2382c00b4.png)
![](https://telegraph-image-aed.pages.dev/file/fecbaa4011855de61db50.png)

还有一张以资源共享角度描绘的图：
![](https://telegraph-image-aed.pages.dev/file/8ac898aebeab3e0fb6eb7.png)

Method Area（Non-Heap）（方法区） , Heap（堆） , Program Counter Register（程序计数器） ,   VM Stack（虚拟机栈，也有翻译成JAVA 方法栈的）,Native Method Stack  （ 本地方法栈 ）；
 JVM初始运行的时候都会分配好 Method Area（方法区） 和 Heap（堆） ，而JVM 每遇到一个线程，就为其分配一个 Program Counter Register（程序计数器） ,   VM Stack（虚拟机栈）和Native Method Stack  （本地方法栈），（这也能理解为什么线程会消耗较多资源了，还有递归。。。。）

### 程序计数器

程序计数器是一块较小的内存区域，作用可以看做是当前线程执行的字节码的位置指示器。分支、循环、跳转、异常处理和线程恢复等基础功能都需要依赖这个计算器来完成，不多说。

### 虚拟机栈

先来了解下JAVA指令的构成：
JAVA指令由   操作码  （方法本身）和   操作数   （方法内部变量）  组成。
1）方法本身是指令的 操作码 部分，保存在Stack中；
2）方法内部变量（局部变量）作为指令的 操作数 部分，跟在指令的操作码之后，保存在Stack中（实际上是简单类型（int,byte,short 等）保存在Stack中，对象类型在Stack中保存地址，在Heap 中保存值）；
虚拟机 栈也叫栈内存，是在线程创建时创建，它的 生命期是跟随线程的生命 期 ，线程结束栈内存也就释放， 对于栈来说不存在垃圾回收问题，只要线程一结束，该栈就 Over，所以不存在垃圾回收 。 也有一些资料翻译成JAVA方法栈，大概是因为它所描述的是java方法执行的内存模型，每个方法执行的同时创建帧栈（Strack Frame）用于存储局部变量表（包含了对应的方法参数和局部变量），操作栈（Operand Stack，记录出栈、入栈的操作），动态链接、方法出口等信息，每个方法被调用直到执行完毕的过程，对应这帧栈在虚拟机栈的入栈和出栈的过程。
局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象的引用（reference类型，不等同于对象本身，根据不同的虚拟机实现，可能是一个指向对象起始地址的引用指针，也可能是一个代表对象的句柄或者其他与对象相关的位置）和 returnAdress类型（指向下一条字节码指令的地址）。局部变量表所需的内存空间在编译期间完成分配，在方法在运行之前，该局部变量表所需要的内存空间是固定的，运行期间也不会改变。
栈帧是一个内存区块，是一个数据集， 是 一个有关方法(Method)和运行期数据的数据集 ，当一个方法 A 被调用时就产生了一个栈帧 F1，并 被压入到栈中，A 方法又调用了 B 方法，于是产生栈帧 F2 也被压入栈，执行完毕后，先弹出 F2 栈帧，再弹出 F1 栈帧，遵循“ 先进后出 ”原则。 光说比较枯燥，我们看一个图来理解一下 Java 栈，如下图所示：
![](https://telegraph-image-aed.pages.dev/file/f71960addfe89d2532270.png)

### Heap
Heap（堆）是JVM的内存数据区。Heap 的管理很复杂，是被所有线程共享的内存区域，在JVM启动时候创建，专门用来保存对象的实例。在Heap 中分配一定的内存来保存对象实例，实际上也只是保存对象实例的属性值，属性的类型和对象本身的类型标记等，并不保存对象的方法（以帧栈的形式保存在Stack中）,在Heap 中分配一定的内存保存对象实例。而对象实例在Heap 中分配好以后，需要在Stack中保存一个4字节的Heap 内存地址，用来定位该对象实例在Heap 中的位置，便于找到该对象实例，是垃圾回收的主要场所。java堆处于物理不连续的内存空间中，只要逻辑上连续即可。
 
### Method Area
Object Class Data(加载类的类定义数据)  是存储在方法区的。除此之外， 常量 、 静态变量、JIT(即时编译器)编译后的代码也都在方法区。正因为方法区所存储的数据与堆有一种类比关系，所以它还被称为 Non-Heap。方法区也可以是内存不连续的区域组成的，并且可设置为固定大小，也可以设置为可扩展的，这点与堆一样。
垃圾回收在这个区域会比较少出现，这个区域内存回收的目的主要针对常量池的回收和类的卸载。

### 运行时常量池（Runtime Constant Pool）
 
方法区内部有一个非常重要的区域，叫做 运行时常量池（Runtime Constant Pool，简称 RCP） 。在字节码文件（Class文件）中，除了有类的版本、字段、方法、接口等先关信息描述外，还有常量池（Constant Pool Table）信息，用于存储编译器产生的字面量和符号引用。这部分内容在类被加载后，都会存储到方法区中的RCP。值得注意的是，运行时产生的新常量也可以被放入常量池中，比如 String 类中的 intern() 方法产生的常量。
 
常量池就是这个类型用到的常量的一个有序集合。包括 直接常量(基本类型，String) 和 对其他类型、方法、字段的符号引用.例如：
 
◆类和接口的全限定名；
◆字段的名称和描述符；
◆方法和名称和描述符。
池中的数据和数组一样通过索引访问。由于常量池包含了一个类型所有的对其他类型、方法、字段的符号引用，所以常量池在Java的动态链接中起了核心作用.
 
很有用且重要关于常量池的扩展：Java常量池详解 http://www.cnblogs.com/DreamSea/archive/2011/11/20/2256396.html
 
#### Native Method Stack
 
与VM Strack相似，VM Strack为JVM提供执行JAVA方法的服务，Native Method Stack则为JVM提供使用native 方法的服务。

#### 直接内存区

直接内存区并不是 JVM 管理的内存区域的一部分，而是其之外的。该区域也会在 Java 开发中使用到，并且存在导致内存溢出的隐患。如果你对 NIO 有所了解，可能会知道 NIO 是可以使用 Native Methods 来使用直接内存区的。

#### 小结
在此，你对JVM的内存区域有了一定的理解，JVM内存区域可以分为线程共享和非线程共享两部分，线程共享的有堆和方法区，非线程共享的有虚拟机栈，本地方法栈和程序计数器。
1. 分清什么是实例什么是对象。Class a= new Class();此时a叫实例，而不能说a是对象。实例在栈中，对象在堆中，操作实例实际上是通过实例的指针间接操作对象。多个实例可以指向同一个对象。
2. 栈中的数据和堆中的数据销毁并不是同步的。方法一旦结束，栈中的局部变量立即销毁，但是堆中对象不一定销毁。因为可能有其他变量也指向了这个对象，直到栈中没有变量指向堆中的对象时，它才销毁，而且还不是马上销毁，要等垃圾回收扫描时才可以被销毁。
3. 以上的栈、堆、代码段、数据段等等都是相对于应用程序而言的。每一个应用程序都对应唯一的一个JVM实例，每一个JVM实例都有自己的内存区域，互不影响。并且这些内存区域是所有线程共享的。这里提到的栈和堆都是整体上的概念，这些堆栈还可以细分。
4. 类的成员变量在不同对象中各不相同，都有自己的存储空间(成员变量在堆中的对象中)。而类的方法却是该类的所有对象共享的，只有一套，对象使用方法的时候方法才被压入栈，方法不使用则不占用内存。

## 垃圾回收

这里补充下堆内存的垃圾回收机制：
● 新生代。新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例
● 老年代。用于存放新生代中经过多次垃圾回收仍然存活的对象
● 持久带（Permanent Space）实现方法区，主要存放所有已加载的类信息，方法信息，常量池等等。可通过-XX:PermSize和-XX:MaxPermSize来指定持久带初始化值和最大值。Permanent Space并不等同于方法区，只不过是Hotspot JVM用Permanent Space来实现方法区而已，有些虚拟机没有Permanent Space而用其他机制来实现方法区。

### 常见垃圾回收参数

● -Xmx:最大堆内存,如：-Xmx512m
● -Xms:初始时堆内存,如：-Xms256m
● -XX:MaxNewSize:最大年轻区内存
-XX:NewSize:初始时年轻区内存.通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90%
-XX:MaxPermSize:最大持久带内存
-XX:PermSize:初始时持久带内存
-XX:+PrintGCDetails。打印 GC 信息
 -XX:NewRatio 新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的1/3，老年代占2/3
 -XX:SurvivorRatio 新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10
 注意：栈内存设置：-xss:设置每个线程的堆栈大小. JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的话， 1M 是绝对够用了的。

#### 垃圾回收算法
 
标记-清除（Mark-Sweep）:此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。
![](https://telegraph-image-aed.pages.dev/file/f3a8ad5d3783f3260f307.png)
 
复制（Copying）:此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。
![](https://telegraph-image-aed.pages.dev/file/30afeabf9f23a6ffd748f.png)
 
标记-整理（Mark-Compact）:此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。
![](https://telegraph-image-aed.pages.dev/file/83cc37d48c534311cab7e.png)
 
#### 垃圾回收机制

JVM分别对新生代和老年代采用不同的垃圾回收机制
新生代的GC：
    新生代通常存活时间较短，因此基于Copying算法来进行回收，所谓Copying算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中，对应于新生代，就是在Eden和From Space或To Space之间copy。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。当连续分配对象时，对象会逐渐从eden到survivor，最后到老年代。
    在执行机制上JVM提供了串行GC（Serial GC）、并行回收GC（Parallel Scavenge）和并行GC（ParNew）
    1）串行GC
        在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式，可以通过-XX:+UseSerialGC来强制指定
    2）并行回收GC
        在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式，可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数
    3）并行GC
    与老年代的并发GC配合使用
老年代的GC：
    老年代与新生代不同，对象存活的时间比较长，比较稳定，因此采用标记（Mark）算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并，要么标记出来便于下次进行分配，总之就是要减少内存碎片带来的效率损耗。在执行机制上JVM提供了串行GC（Serial MSC）、并行GC（parallel MSC）和并发GC（CMS），具体算法细节还有待进一步深入研究。
以上各种GC机制是需要组合使用的，指定方式由下表所示： 
 